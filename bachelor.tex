\documentclass{scrreprt}
\usepackage{fontspec}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{csquotes}

% Define additional header fields
\makeatletter
\newcommand\Doctype[1]{\renewcommand\@Doctype{#1}}
\newcommand\@Doctype{\@latex@error{No \noexpand\Doctype given}\@ehc}

\newcommand\doctype[1]{\renewcommand\@doctype{#1}}
\newcommand\@doctype{\@latex@error{No \noexpand\doctype given}\@ehc}

\newcommand\germanTitle[1]{\renewcommand\@germanTitle{#1}}
\newcommand\@germanTitle{\@latex@error{No \noexpand\germanTitle given}\@ehc}

\newcommand\supervisor[1]{\renewcommand\@supervisor{#1}}
\newcommand\@supervisor{\@latex@error{No \noexpand\supervisor given}\@ehc}

\newcommand\advisor[1]{\renewcommand\@advisor{#1}}
\newcommand\@advisor{\@latex@error{No \noexpand\advisor given}\@ehc}

\newcommand\location[1]{\renewcommand\@location{#1}}
\newcommand\@location{\@latex@error{No \noexpand\location given}\@ehc}
\makeatother

\newcommand\inline[1]{{\addfontfeature{Letters=SmallCaps}#1}}

\Doctype{Bachelor's thesis}
\doctype{bachelor's thesis}

\author{Marek Kubica}
\title{A functional streaming API for OCaml}
\germanTitle{Eine funktionale Programmierschnittstelle für Datenströme in OCaml}
\supervisor{Prof. Dr. Alois Knoll}
\advisor{Markus Weißmann, M.Sc.}
\location{München}
\date{\today}

\setmainfont{Linux Libertine O}
\setsansfont{Linux Biolinum O}
\setmonofont{Droid Sans Mono Dotted}

\hypersetup{
%	bookmarks=true,          % show bookmarks bar?
%	unicode=false,           % non-Latin characters in Acrobat’s bookmarks
%	pdftoolbar=true,         % show Acrobat’s toolbar?
%	pdfmenubar=true,         % show Acrobat’s menu?
%	pdffitwindow=false,      % window fit to page when opened
	pdfstartview={FitH},     % fits the width of the page to the window
	pdftitle={A functional streaming API for OCaml},     % title
	pdfauthor={Marek Kubica},   % author
	pdfsubject={Bachelor's thesis}, % subject of the document
%	pdfcreator={Creator},    % creator of the document
%	pdfproducer={Producer},  % producer of the document
	pdfkeywords={ocaml} {libarchive} {functional}, % list of keywords
%	pdfnewwindow=true,       % links in new window
	colorlinks=true,         % false: boxed links; true: colored links
	linkcolor=black,         % color of internal links (original: red)
%	linktoc=section          % which part of a toc-entry to link (possible: none, section, page, all)
	citecolor=black,         % color of links to bibliography (original: green)
	filecolor=black,         % color of file links (original: magenta)
	urlcolor=black,          % color of external links (original: cyan)
%	linkbordercolor={1 0 0}, % color of frame around internal links (if colorlinks=false)
%	citebordercolor={0 1 0}, % color of frame around citations (if colorlinks=false)
%	urlbordercolo={0 1 1}    % color of frame around URL links (if colorlinks=false)
}

\begin{document}

\input{cover}
\input{titlepage}
\input{disclaimer}

\phantomsection
\addcontentsline{toc}{chapter}{Abstract}
\begin{abstract}
	\subsubsection*{\abstractname}
	Bla bla bla
\end{abstract}

\tableofcontents

\chapter{Introduction}
\label{sec:intro}

Processing data is the use-case computers were invented for: doing calculations
that are too complicated for manual computation or too time-consuming.
Therefore, in the history of computing the representation of data was always
very important. Usual hardware architectures used only to operate on scalar
values, because the registers of CPUs could only store scalar values.

Computers are very good at repeating tasks, so it is only natural to extend the
processing of one record to processing multiple records on which the
computation is repeated. Early computers worked on data in a batch structure,
by reading a record from punch cards, computing the result and writing the
result to punch cards. Later systems used their built-in memory to hold the
data and multiple ways to organize this data were possible.

One way to organize was using fixed-size arrays of values on which one
particular operation was executed. Languages organizing data this way are APL
and its sucessors J and K for example. Another example is the x86 assembly
language with its special-purpose MMX and SSE extensions which compute on sets
of registers holding floating point values.

An alternative is the \emph{list} abstraction. Seemingly similar to arrays, the
high-level difference with lists is that lists do not usually have a fixed
length. While arrays are usually implemented as sequence of data in memory,
list implementations can be very flexible with different advantages and
disadvantages. A very important language family that utilizes lists heavily is
Lisp where even the source code is written in a list structure. Usually, all
modern languages provide a convenient way to handle lists, many also provide
syntactic extensions.

In functional programming in particular, lists have been very important. Many
languages utilize operators like \inline{first} and \inline{rest} to get the
first element of the list and the remainder of the list. The second element can
be expressed via \inline{first}, \inline{rest} and recursion. OCaml in
particular provides \emph{pattern matching} and a special syntax to destructure
lists in this way.

An evolution of lists is the \emph{sequence} abstraction. Lists are limited by
the available memory to hold all the records, whereas a sequence does not need
to.  To make this possible, sequences sacrifice some features of lists like
random access on each record and instead provide a way to get the first
element. As we saw, in the context of functional programming, this restriction
is not problematic as other ways to work with this data exist.

These sequences might be \emph{lazy}, meaning that the sequence can be created
without having to evaluate all values of itself. These values need only be
evaluated when the head of the sequence is requested.

OCaml is currently missing a solid implementation of these streams, therefore
the objective in this bachelor's thesis is to provide a functional
implementation of streams that can be composed. The effectiveness of this
stream library is then demonstrated by building a library for data compression
on top of it.

\chapter{Overview of existing solutions}
\label{sec:solutions}

Lazy streams are a feature that many languages support since there is one
specific use-case that nearly all languages support and that can only be
reasonably implemented with a veriant of lazy streams: file handling.

Most systems allow files to grow much larger than the operating memory of the
system, therefore holding all data in memory is impossible. Yet languages need
to support reading and writing such files. So the languages need to have an
implementation of a data type that can be read incrementally, without having to
hold it completely in memory.

A number of popular languages were picked with interesting and contrasting
approaches on this issue, so the advantages and disadvantages can be analyzed.
The insights are used to propose of a good solution for OCaml.

\section{C}
\label{sec:c}

The C programming language hardly needs any introduction, considering it is
among the most widely used programming languages. Unlike many others, the C
programming language is rather old and lacking some modern features. The C type
system essentially only knows about numbers: pointers are a special case of
numbers and strings are also represented as arrays of numbers.

Therefore, with the lack of syntactic support many libraries have to emulate
functionality using functions and macros. One very fundamental library for C is
of course the Standard Library (\enquote{stdlib}) which is usually provided by
a library called \enquote{libc} and shipped by the operating system.

This basic library provides functions for handling strings, copying data in a
convenient way, handling files and many more. In fact, handling files is one of
the tasks where streaming data is useful since otherwise the whole file would
need to fit completely in memory. When C was first designed, main memory was
several magnitudes smaller than currently, so the designers had to come up with
a solution.

The C solution is to use an interface that comes directly from the operating
system: file descriptors. File descriptiors (FDs) are basically just integer
numbers that reference an opened file. This concept can be even considered lazy
evaluated, since opening a file does not require reading its contents. In C,
file descriptors are usually wrapped in a data type called \inline{FILE}, but
working directly with the descriptors directly is also possible, if somewhat
less convenient.

A file is read by using a stdlib function called \inline{fread} which takes a
buffer as a first argument, as location on where to save the data read in main
memory, a size indicator for letting the system know how big one element of the
buffer is, a count, to notify how many elements to read and finally an opened
file, wrapped by the \inline{FILE} type\footnote{A similar function
\inline{read} does the same thing with a file descriptor instead of a
\inline{FILE}}. An analogous functionality is implemented by \inline{fwrite} to
write data to files.

This functionality seems limited to files, but that is not the case. C also
knows 3 \enquote{files} that are not actually files: \inline{stdin} for reading
data from the user, \inline{stdout} for writing output to the user and
\inline{stderr} for writing error output. These references can be used where a
\inline{FILE} is required and do not need to be saved to disk. Thus C has
\emph{some} support for streaming data.

TODO: add demonstration on how to read a file.

With a streaming API in place, there are a number of tasks that are a natural
fit, for example compression of data. An uncompressed data stream gets in, a
compressed stream comes out with the encryption function as a bleack box. Such
compression algorithms exist since years and are very popular and common.
Examples include gzip\footnote{TODO} and bzip2\footnote{TODO}, each tailored to
different use cases: good compression ratio, fast decompression, good
compression ratios on specific types of data etc.

Libraries for these algorithms are implemented most of the time in C
(\inline{zlib} for gzip, \inline{libbz2} for bzip2) or at least have an
interface to be used from C (LZMA reference implementation\footnote{7-Zip
project, TODO}), therefore giving implementers in C a wide variety to choose
from. Unfortunately, these libraries all provide different APIs, so just
switching the compression algorithm from gzip to bzip2 is not very convenient.
This problem can be solved with libarchive\footnote{TODO}, a wrapper around a
huge amount of different compression libraries. Furthermore, libarchive
provides implementations of common container formats like \inline{TAR} or
\inline{ZIP}.

For this bachelor's thesis, implementing compression algorithms is
out-of-scope, so using libarchive as a way to implement compression
functionality is a perfect fit. One big advantage of libarchive is that it is a
universal wrapper, so adding new algorithms can be done completely within
libarchive while all users of libarchive, like this bachelor thesis, can profit
and do not suffer duplication of efforts.

\section{Java}
\label{sec:java}

\section{Python}
\label{sec:python}

Python is a dynamically-typed high level language designed in the the Nineties
and enjoying constant improvement. It has seen rising adoption in the last few
years in scientific communities as well as for web development. Much of this
apotion can be attributed to the simplicity of the language and the thriving
ecosystem.

Contrasted to Java, Pythons solution to problems tend to fall on the more
pragmatic side. TODO

One important concept in Python is so called
\emph{duck-typing}\footnote{\emph{If it walks like a duck, if it quacks like a
duck, then it is a duck} is the typical explanation of this term} in which
there is no formal interface like in Java but rather objects that provide
specific behaviors.

This means that every object can support any interface, as long as it provides
the proper methods and returns the proper values. No special definitions are
required and there is no required class hierarchy.

\subsection{Iterables}
\label{sec:pyiterable}

One important interface in Python is the \emph{Iterable}, that is an object
over which it is possible to iterate. Iterables are only required to support
very limited operations:

\begin{itemize}

  \item Provide a \inline{\_\_next\_\_} method which returns the next value of
	  the iterable.

  \item Throw a \inline{StopIteration} exception after the last element was
	  returned.  This is used to denote that the iterable was consumed and
	  will not provide any more values.

\end{itemize}

Python's built-in datatypes support this interface, therefore implementing
these interfaces in custom types enables the standard Python syntax to use them
just like every other type. In particular, lists support this interface but
also strings and files as well.

TODO: add code that implements an iterable

Python also has additional syntactic support for so called \emph{generators}
which are ordinary functions that use the \inline{yield} keyword instead of
the \inline{return} keyword. This causes the functions return value to turn
into an iterable, return the value and suspend. Each element of the iterable
causes the function to resume and run until the next \inline{yield} is reached.
Reaching the end of the function or a \inline{return} statement causes a
\inline{StopIteration} exception being thrown.

TODO: demonstrate generator

\subsection{File-like objects}
\label{sec:pyfile}

\chapter{Implementation}
\label{sec:implementation}

\section{Architecture}
\label{sec:architecture}

TODO: TikZ picture

\section{Compression}
\label{sec:compression}

There are many possibilities to demonstrate the use of a streaming library so
to find an application which is interesting enough for the thesis while not too
complex to exceed the scope, compression is a good fit.

From the viewpoint of the OCaml software ecosystem, this pick makes sense, as
there is no widely adopted software library to deal with compression in a
universal way. There is a number of solutions an OCaml programmer can choose
from, but each suffers from some problems.

\subsection{Possible alternatives}
\label{sec:alternatives}

There is some selection in solutions that cover only some of the functionality
that is usually expected from a compression library.

\begin{itemize}
  \item camlzip\footnote{\url{https://forge.ocamlcore.org/projects/camlzip/}}:
    Mature library, but supports only Zip archives. One specific limitation is
    the lack of support for in-memory data which requires to read and write
    temporary files causing bad performance. Also, appears to be in maintenance
    mode with hardly any changes in the last years.
  \item OCamlBZ2\footnote{\url{https://forge.ocamlcore.org/projects/camlbz2/}}:
    This library is limited to handle only bz2 compression and is a direct
    binding to libbz2. Maintenance of the library seems to have stopped many
    years ago after only two releases. One disadvantage is that raw bz2
    streams are rare — usually multiple files are wrapped in tar archives,
    for which this library has no support.
  \item ocaml-tar\footnote{\url{https://github.com/samoht/ocaml-tar}}:
    implements tar format archives in pure OCaml code. This implements
    \emph{one} type of tar, whereas libarchive supports multiple variants.
  \item ocaml-archive\footnote{\url{https://forge.ocamlcore.org/projects/ocaml-archive/}}:
    The most comparable library to this effort, unfortunately not a complete
    binding and only one single version ever released that binds an old version
    of libarchive that is considered \enquote{legacy} by the libarchive
    developers. Yet useful for transfering some ideas on how to bind the
    library.
\end{itemize}

\subsection{Foreign function interface}
\label{sec:ffi}

\section{Low-level binding}
\label{sec:lowlevel}

\section{Functional streaming interface}
\label{sec:functional}

\chapter{Discussion}
\label{sec:discussion}

\bibliographystyle{plain}
\bibliography{bachelor}
\end{document}
