\documentclass{scrreprt}
\usepackage{fontspec}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{hyperref}

% Define additional header fields
\makeatletter
\newcommand\Doctype[1]{\renewcommand\@Doctype{#1}}
\newcommand\@Doctype{\@latex@error{No \noexpand\Doctype given}\@ehc}

\newcommand\doctype[1]{\renewcommand\@doctype{#1}}
\newcommand\@doctype{\@latex@error{No \noexpand\doctype given}\@ehc}

\newcommand\germanTitle[1]{\renewcommand\@germanTitle{#1}}
\newcommand\@germanTitle{\@latex@error{No \noexpand\germanTitle given}\@ehc}

\newcommand\supervisor[1]{\renewcommand\@supervisor{#1}}
\newcommand\@supervisor{\@latex@error{No \noexpand\supervisor given}\@ehc}

\newcommand\advisor[1]{\renewcommand\@advisor{#1}}
\newcommand\@advisor{\@latex@error{No \noexpand\advisor given}\@ehc}

\newcommand\location[1]{\renewcommand\@location{#1}}
\newcommand\@location{\@latex@error{No \noexpand\location given}\@ehc}
\makeatother

\newcommand\inline[1]{{\addfontfeature{Letters=SmallCaps}#1}}

\Doctype{Bachelor's thesis}
\doctype{bachelor's thesis}

\author{Marek Kubica}
\title{TODO}
\germanTitle{TODO}
\supervisor{Prof. Dr. Alois Knoll}
\advisor{Markus Weißmann, M.Sc.}
\location{München}
\date{\today}

\setmainfont{Linux Libertine O}
\setsansfont{Linux Biolinum O}
\setmonofont{Droid Sans Mono Dotted}

\hypersetup{
%	bookmarks=true,          % show bookmarks bar?
%	unicode=false,           % non-Latin characters in Acrobat’s bookmarks
%	pdftoolbar=true,         % show Acrobat’s toolbar?
%	pdfmenubar=true,         % show Acrobat’s menu?
%	pdffitwindow=false,      % window fit to page when opened
	pdfstartview={FitH},     % fits the width of the page to the window
	pdftitle={TODO},     % title
	pdfauthor={Marek Kubica},   % author
	pdfsubject={Bachelor's thesis}, % subject of the document
%	pdfcreator={Creator},    % creator of the document
%	pdfproducer={Producer},  % producer of the document
	pdfkeywords={ocaml} {libarchive} {functional}, % list of keywords
%	pdfnewwindow=true,       % links in new window
	colorlinks=true,         % false: boxed links; true: colored links
	linkcolor=black,         % color of internal links (original: red)
%	linktoc=section          % which part of a toc-entry to link (possible: none, section, page, all)
	citecolor=black,         % color of links to bibliography (original: green)
	filecolor=black,         % color of file links (original: magenta)
	urlcolor=black,          % color of external links (original: cyan)
%	linkbordercolor={1 0 0}, % color of frame around internal links (if colorlinks=false)
%	citebordercolor={0 1 0}, % color of frame around citations (if colorlinks=false)
%	urlbordercolo={0 1 1}    % color of frame around URL links (if colorlinks=false)
}

\begin{document}

\input{cover}
\input{titlepage}
\input{disclaimer}

\phantomsection
\addcontentsline{toc}{chapter}{Abstract}
\begin{abstract}
	\subsubsection*{\abstractname}
	Bla bla bla
\end{abstract}

\tableofcontents

\chapter{Introduction}
\label{sec:intro}

Processing data is the use-case computers were invented for: doing calculations
that are too complicated for manual computation or too time-consuming.
Therefore, in the history of computing the representation of data was always
very important. Usual hardware architectures used only to operate on scalar
values, because the registers of CPUs could only store scalar values.

Computers are very good at repeating tasks, so it is only natural to extend the
processing of one record to processing multiple records on which the
computation is repeated. Early computers worked on data in a batch structure,
by reading a record from punch cards, computing the result and writing the
result to punch cards. Later systems used their built-in memory to hold the
data and multiple ways to organize this data were possible.

One way to organize was using fixed-size arrays of values on which one
particular operation was executed. Languages organizing data this way are APL
and its sucessors J and K for example. Another example is the x86 assembly
language with its special-purpose MMX and SSE extensions which compute on sets
of registers holding floating point values.

An alternative is the \emph{list} abstraction. Seemingly similar to arrays, the
high-level difference with lists is that lists do not usually have a fixed
length. While arrays are usually implemented as sequence of data in memory,
list implementations can be very flexible with different advantages and
disadvantages. A very important language family that utilizes lists heavily is
Lisp where even the source code is written in a list structure. Usually, all
modern languages provide a convenient way to handle lists, many also provide
syntactic extensions.

In functional programming in particular, lists have been very important. Many
languages utilize operators like \inline{first} and \inline{rest} to get the
first element of the list and the remainder of the list. The second element can
be expressed via \inline{first}, \inline{rest} and recursion. OCaml in
particular provides \emph{pattern matching} and a special syntax to destructure
lists in this way.

An evolution of lists is the \emph{sequence} abstraction. Lists are limited by
the available memory to hold all the records, whereas a sequence does not need
to.  To make this possible, sequences sacrifice some features of lists like
random access on each record and instead provide a way to get the first
element. As we saw, in the context of functional programming, this restriction
is not problematic as other ways to work with this data exist.

These sequences might be \emph{lazy}, meaning that the sequence can be created
without having to evaluate all values of itself. These values need only be
evaluated when the head of the sequence is requested.

OCaml is currently missing a solid implementation of these streams, therefore
the objective in this bachelor's thesis is to provide a functional
implementation of streams that can be composed. The effectiveness of this
stream library is then demonstrated by building a library for data compression
on top of it.

\chapter{Overview of existing solutions}
\label{sec:solutions}

Lazy streams are a feature that many languages support since there is one
specific use-case that nearly all languages support and that can only be
reasonably implemented with a veriant of lazy streams: file handling.

Most systems allow files to grow much larger than the operating memory of the
system, therefore holding all data in memory is impossible. Yet languages need
to support reading and writing such files. So the languages need to have an
implementation of a data type that can be read incrementally, without having to
hold it completely in memory.

A number of popular languages were picked with interesting and contrasting
approaches on this issue, so the advantages and disadvantages can be analyzed.
The insights are used to propose of a good solution for OCaml.

\section{C++}
???

\section{Java}
\label{sec:java}

\section{Python}
\label{sec:python}

Python is a dynamically-typed high level language designed in the the Nineties
and enjoying constant improvement. It has seen rising adoption in the last few
years in scientific communities as well as for web development. Much of this
apotion can be attributed to the simplicity of the language and the thriving
ecosystem.

Contrasted to Java, Pythons solution to problems tend to fall on the more
pragmatic side. TODO

One important concept in Python is so called
\emph{duck-typing}\footnote{\emph{If it walks like a duck, if it quacks like a
duck, then it is a duck} is the typical explanation of this term} in which
there is no formal interface like in Java but rather objects that provide
specific behaviors.

This means that every object can support any interface, as long as it provides
the proper methods and returns the proper values. No special definitions are
required and there is no required class hierarchy.

\subsection{Iterables}
\label{sec:pyiterable}

One important interface in Python is the \emph{Iterable}, that is an object
over which it is possible to iterate. Iterables are only required to support
very limited operations:

\begin{itemize}

  \item Provide a \inline{\_\_next\_\_} method which returns the next value of
	  the iterable.

  \item Throw a \inline{StopIteration} exception after the last element was
	  returned.  This is used to denote that the iterable was consumed and
	  will not provide any more values.

\end{itemize}

Python's built-in datatypes support this interface, therefore implementing
these interfaces in custom types enables the standard Python syntax to use them
just like every other type. In particular, lists support this interface but
also strings and files as well.

TODO: add code that implements an iterable

Python also has additional syntactic support for so called \emph{generators}
which are ordinary functions that use the \inline{yield} keyword instead of
the \inline{return} keyword. This causes the functions return value to turn
into an iterable, return the value and suspend. Each element of the iterable
causes the function to resume and run until the next \inline{yield} is reached.
Reaching the end of the function or a \inline{return} statement causes a
\inline{StopIteration} exception being thrown.

TODO: demonstrate generator

\subsection{File-like objects}
\label{sec:pyfile}


\section{Lisp}

\section{Haskell}
\label{sec:haskell}

\chapter{Inplementation}
\label{sec:implementation}

\chapter{Discussion}
\label{sec:discussion}

\bibliographystyle{plain}
\bibliography{bachelor}
\end{document}
