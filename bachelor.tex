\documentclass[parskip=half]{scrreprt}
\usepackage{fontspec}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{minted}
\usepackage{tikz}
\usepackage{chngcntr}
\usepackage{amstext}
\usepackage[normalem]{ulem}
\usepackage{biblatex}
\usepackage{haskelllogo}

\bibliography{bachelor}

% red underline, nice for correction things
% http://tex.stackexchange.com/questions/7321/how-to-color-just-the-wave-produced-by-the-ulem-package
\makeatletter
\def\uwave{\bgroup \markoverwith{\lower3.5\p@\hbox{\sixly \textcolor{red}{\char58}}}\ULon}
\font\sixly=lasy6 % does not re-load if already loaded, so no memory problem.
\makeatother

% Define additional header fields
\makeatletter
\newcommand\Doctype[1]{\renewcommand\@Doctype{#1}}
\newcommand\@Doctype{\@latex@error{No \noexpand\Doctype given}\@ehc}

\newcommand\doctype[1]{\renewcommand\@doctype{#1}}
\newcommand\@doctype{\@latex@error{No \noexpand\doctype given}\@ehc}

\newcommand\germanTitle[1]{\renewcommand\@germanTitle{#1}}
\newcommand\@germanTitle{\@latex@error{No \noexpand\germanTitle given}\@ehc}

\newcommand\supervisor[1]{\renewcommand\@supervisor{#1}}
\newcommand\@supervisor{\@latex@error{No \noexpand\supervisor given}\@ehc}

\newcommand\advisor[1]{\renewcommand\@advisor{#1}}
\newcommand\@advisor{\@latex@error{No \noexpand\advisor given}\@ehc}

\newcommand\location[1]{\renewcommand\@location{#1}}
\newcommand\@location{\@latex@error{No \noexpand\location given}\@ehc}
\makeatother

% do not restart counters on every chapter
% provided by the chngcntr package
\counterwithout{footnote}{chapter}

\newcommand\inline[1]{{\addfontfeature{Letters=SmallCaps}#1}}

\Doctype{Bachelor's thesis}
\doctype{bachelor's thesis}

\author{Marek Kubica}
\title{A functional streaming API for OCaml}
\germanTitle{Eine funktionale Programmierschnittstelle für Datenströme in OCaml}
\supervisor{Prof. Dr. Alois Knoll}
\advisor{Markus Weißmann, M.Sc.}
\location{München}
\date{\today}

\setmainfont{Linux Libertine O}
\setsansfont{Linux Biolinum O}
\setmonofont[Scale=0.8]{Droid Sans Mono Dotted}

\usemintedstyle{tango}

\hypersetup{
%	bookmarks=true,          % show bookmarks bar?
%	unicode=false,           % non-Latin characters in Acrobat’s bookmarks
%	pdftoolbar=true,         % show Acrobat’s toolbar?
%	pdfmenubar=true,         % show Acrobat’s menu?
%	pdffitwindow=false,      % window fit to page when opened
	pdfstartview={FitH},     % fits the width of the page to the window
	pdftitle={A functional streaming API for OCaml},     % title
	pdfauthor={Marek Kubica},   % author
	pdfsubject={Bachelor's thesis}, % subject of the document
%	pdfcreator={Creator},    % creator of the document
%	pdfproducer={Producer},  % producer of the document
	pdfkeywords={ocaml} {libarchive} {functional}, % list of keywords
%	pdfnewwindow=true,       % links in new window
	colorlinks=true,         % false: boxed links; true: colored links
	linkcolor=black,         % color of internal links (original: red)
%	linktoc=section          % which part of a toc-entry to link (possible: none, section, page, all)
	citecolor=black,         % color of links to bibliography (original: green)
	filecolor=black,         % color of file links (original: magenta)
	urlcolor=black,          % color of external links (original: cyan)
%	linkbordercolor={1 0 0}, % color of frame around internal links (if colorlinks=false)
%	citebordercolor={0 1 0}, % color of frame around citations (if colorlinks=false)
%	urlbordercolo={0 1 1}    % color of frame around URL links (if colorlinks=false)
}

\providecommand*{\listingautorefname}{Listing}
% write section instead of subsection in the text, less awkward
\renewcommand*{\subsectionautorefname}{section}
\hyphenation{lib-ar-chi-ve}

\begin{document}

\input{cover}
\input{titlepage}
\input{disclaimer}

\phantomsection
\addcontentsline{toc}{chapter}{Abstract}

\begin{abstract}
\subsubsection*{\abstractname}

% Say: streaming
% Say: compression
% Say: simple api
% Say: ocaml

There is much data that can be processed sequentially so there exist many
approaches to deal with it. One of these is processing this data in
\enquote{streams} of informations that are being transformed. In this thesis,
we look at streaming APIs and figure out ways how to deal with them in a
functional fashion with specific focus on the implementation in OCaml. As an
application of such stream processing, we will implement a library for data
compression using a functional, yet easy to use API and fill a void in the
OCaml ecosystem.

\end{abstract}

\tableofcontents

\chapter{Introduction}
\label{sec:intro}

Processing data is the use-case computers were invented for: doing calculations
that are too complicated for manual computation or too time-consuming.  In the
history of computing the representation of data was always very important.
Usual hardware architectures used only to operate on scalar values, because the
registers of CPUs could only store scalar values.

Computers are very good at repeating tasks, so it is only natural to extend the
processing of one record to processing multiple records on which the
computation is repeated. Early computers worked on data in a batch structure,
by reading a record from punch cards, computing the result and writing the
result to punch cards. Later systems used their built-in memory to hold the
data and multiple ways to organize this data were possible.

One way to organize was using arrays of values on which one particular
operation was executed. Some languages organizing data this way are
APL~\cite{biancuzzi2009masterminds} and its sucessors J and K.  Another example
is the x86 assembly language with its special-purpose MMX and SSE extensions
which compute on sets of registers holding floating point values.

An alternative is the \emph{list} abstraction. Seemingly similar to arrays, the
high-level difference with lists is that lists do not usually have a fixed
length. While arrays are usually implemented as sequence of data in memory,
list implementations can be very flexible with different advantages and
disadvantages. A very important language family that utilizes lists heavily is
Lisp where even the source code is written in a list structure. Usually, all
modern languages provide a convenient way to handle lists, many also provide
syntactic extensions.

In functional programming in particular, lists have been very important. Many
languages utilize operators like \inline{first} and \inline{rest} to get the
first element of the list and the remainder of the list. Consequent element can
be expressed via recursive calls to \inline{first} and \inline{rest}. OCaml in
particular provides \emph{pattern matching} and a special syntax to destructure
lists in this way~\cite{hickey2013real}.

An evolution of lists is the \emph{sequence} abstraction. Lists are limited by
the available memory to hold all the records, whereas a sequence does not need
to.  To make this possible, sequences sacrifice some features of lists like
random access on each record and instead provide a way to get the first
element. As we saw, this restriction is not problematic as other ways to work
with this data exist.

These sequences might be \emph{lazy}, meaning that the sequence can be created
without having to evaluate all values of itself. These values need only be
evaluated when the head of the sequence is requested.

OCaml is currently missing a solid implementation of these streams, therefore
the objective in this bachelor's thesis is to provide a functional
implementation of streams that can be composed. The effectiveness of this
stream library is then demonstrated by building a library for data compression
on top of it.

\chapter{Overview of existing solutions}
\label{sec:solutions}

Lazy streams are a feature that many languages support since there is one
specific use-case that nearly all languages have to support and that can only
be reasonably implemented with a variant of lazy streams: file handling.
Therefore, looking at the usual way of handling files in each language is a
good way to see how these kinds of streams are handled.

Most systems allow files to grow much larger than the operating memory of the
system, therefore holding all data in memory is infeasible. Some files might
even be virtually infinite, like named FIFOs or Unix sockets that can be found
in many flavors of Unix systems. Yet languages need to support reading and
writing such files. So the languages need to have an implementation of a data
type that can be read incrementally, without having to hold it completely in
memory.

A number of popular languages were picked with interesting and contrasting
approaches on this issue, so the advantages and disadvantages can be analyzed.
The insights are used to propose of a good solution for OCaml.

\section{C}
\label{sec:c}

The C programming language is among the most widely used programming languages.
It was designed in the 1970ies\cite{kernighan1988c} and being meant as a
low-level language is missing some features that are considered modern today.
The C type system essentially only knows about numbers: pointers are a special
case of numbers and strings are also represented as arrays of numbers.

Therefore, with the lack of syntactic support many libraries have to provide
functionality using functions and macros. One very fundamental library for C is
the Standard Library (\enquote{stdlib}) which is usually provided by a library
called \enquote{libc} and shipped by the operating system.

This basic library provides functions for handling strings, copying data in a
convenient way, handling files and many more. In fact, handling files is one of
the tasks where streaming data is useful since otherwise the whole file would
need to fit completely in memory. When C was first designed, main memory was
several magnitudes smaller than currently, so the designers had to come up with
a solution.

The C solution is to use an interface that comes directly from the operating
system: file descriptors. File descriptors (FDs) are basically just integer
numbers that reference an opened file. This concept can be even considered lazy
evaluated, since opening a file does not require reading its contents. In C,
file descriptors are usually wrapped in a data type called \inline{FILE}, but
working directly with the descriptors is also possible, if somewhat less
convenient.

A file is read by using a stdlib function called \inline{fread(3)} which takes
a buffer as a first argument, as location on where to save the data read in
main memory, a size indicator for letting the system know how big one element
of the buffer is, a count, to notify how many elements to read and finally an
opened file, wrapped by the \inline{FILE} type\footnote{A similar function
\inline{read(3)} does the same thing with a file descriptor instead of a
\inline{FILE}}. An analogous functionality is implemented by \inline{fwrite(3)}
to write data to files.

This functionality seems limited to files, but that is not the case. C also
knows 3 \enquote{files} that are not actually files: \inline{stdin} for reading
data from the user, \inline{stdout} for writing output to the user and
\inline{stderr} for writing error output. These references can be used where a
\inline{FILE} is required and do not need to be saved to disk. Thus C has
\emph{some} support for streaming data.

\begin{listing}[H]
  \inputminted[linenos]{c}{readfile.c}
  \caption{Reading file line by line in C, \inline{fgetline()} inspired by
  \inline{getline(3)} from~\cite{kernighan1988c}}
  \label{lst:creadfile}
\end{listing}

\autoref{lst:creadfile} shows how file I/O looks in C. One should note that
this code is not portable C because it uses \inline{fgetln} which is only
available in the C standard library on BSD systems. Yet the example demonstrates
how the \inline{FILE} type is used.

With a streaming API in place, there are a number of tasks that are a natural
fit, for example compression of data. An uncompressed data stream gets in, a
compressed stream comes out with the encryption function as a black box. Such
compression algorithms exist for decades and are very popular and common.
Examples include gzip~\cite{rfc1952} and
bzip2\footnote{\url{http://bzip.org/}}, each tailored to different use cases:
good compression ratio, fast decompression, good compression ratios on specific
types of data etc.

Libraries for these algorithms are often implemented in C
(\inline{zlib} for gzip, \inline{libbz2} for bzip2) or at least have an
interface to be used from C (LZMA reference implementation\footnote{7-Zip
project, \url{http://www.7-zip.org/}}), therefore giving implementers in C a
wide variety to choose from. Unfortunately, these libraries all provide
different APIs, so just switching the compression algorithm from gzip to bzip2
is not very convenient.  This problem can be solved with
libarchive\footnote{\url{http://www.libarchive.org}}, a wrapper around a huge
amount of different compression libraries. Furthermore, libarchive provides
implementations of common container formats like \inline{TAR} or \inline{ZIP}.

Fortunately, since the C application binary interface is mostly
standarized\footnote{TODO: stdcall, C calling conventiosn, Belege} and the
calling conventions are both simple and commonly understood, most languages
provide interfaces to call C code, thus implementing the compression algorithms
in C the most common denominator for a range of languages. These interfaces can
range quite different: from compatibility and linking directly to C code like
C++ does, to dynamically loading the C libraries on runtime via \inline{dlopen}
like Python. OCaml goes a middle way, by requiring glue code in C that
interfaces the C libraries and returns OCaml data types to the OCaml run time.
These functions are then fitted with OCaml type signatures and can then be
directly called from the code as if they were written in OCaml as well.

The primary objective of this bachelor's thesis is not to implement compression
algorithms, so using libarchive as a way to implement compression functionality
is a perfect fit. One big advantage of libarchive is that it is a universal
wrapper, so adding new algorithms can be done completely within libarchive
while all users of libarchive, like this bachelor thesis, can profit and do not
suffer duplication of efforts.

\section{Java}
\label{sec:java}

The Java programming language is an imperative object-oriented language with
support for classes as well as formal interfaces for classes to implement. In
this context, it is interesting to see how Java handles streams and iteration
as these concepts are tightly interlocked.

\subsection{Iterable}
\label{sec:jiterable}

\enquote{Classic} Java, that is Java before version 1.5\footnote{Sometimes
called Java 5} did not have any syntactic support for iteration, so the
canonical way was to use a \inline{for}-loop and call the \inline{iterator}
method on objects that support the \inline{Iterable} interface. This method
returns an object that implements the \inline{Iterator} interface, like shown
in \autoref{lst:jiter4}. This variant is not only verbose but also not type
safe, since the contents of the collection to be iterated over had to be cast
on runtime properly. Failure to do so, e.g. if an element was in the collection
that was of inproper type, would cause an \inline{ClassCastException} to be
thrown.

\begin{listing}[H]
  \begin{minted}[linenos]{java}
// Now a raw iterator type - don't do this!
for (Iterator i = stamps.iterator(); i.hasNext(); ) {
	Stamp s = (Stamp) i.next(); // Throws ClassCastException
    ... // Do something with the stamp
}
  \end{minted}
  \caption{\enquote{Classic} Java style iteration, not type safe and without
    syntactic sugar~\cite{bloch2008effective}}
  \label{lst:jiter4}
\end{listing}

The \inline{Iterator} interface defines three methods: \inline{hasNext} to
determine whether the end of the iterator was reached, \inline{next} to return
the next element of the iterator and an optional method \inline{remove} to
remove the last element of the collection over which the iterator is
iterating~\cite{horstmann2012core}.

\begin{listing}[H]
  \begin{minted}[linenos]{java}
// for loop with parametrized iterator declaration - typesafe
for (Iterator<Stamp> i = stamps.iterator(); i.hasNext(); ) {
    Stamp s = i.next();
    ... // Do something with the stamp
}
  \end{minted}
  \caption{Type safe iteration without syntactic sugar~\cite{bloch2008effective}}
  \label{lst:jiter}
\end{listing}

With the addition of generics in Java 1.5~\cite{bloch2008effective}, the
\inline{next} method was changed to return an element of the containing type
instead of an \inline{Object}, as seen in \autoref{lst:jiter}. This improves
type safety, as the contents of the collection can now be statically tracked by
the compiler and illegal accesses can be detected on compile time.

Java 1.5 also extended the \inline{for} loop syntax to add a variant that can
do the iterator management automatically, such a statement is called the
\enquote{enhanced \inline{for} statement}~\cite{gosling2013java}. This type of
\inline{for} loop creates the iterator on its own, as in \autoref{lst:jiter5}.

\begin{listing}[H]
  \begin{minted}[linenos]{java}
// for-each loop over a parametrized collection - typesafe
for (Stamp s : stamps) {
    ... // Do something with the stamp
}
  \end{minted}
  \caption{Java 1.5-style iteration with syntactic sugar~\cite{bloch2008effective}}
  \label{lst:jiter5}
\end{listing}


\subsection{I/O Streams}
\label{sec:jio}

Java has a very structured approach to input/output. There exists a distinction
between binary streams, represented by \inline{InputStream} and
\inline{OutputStream} and character input, handled by descendants of the
\inline{Reader} and \inline{Writer} classes.

To handle binary data, one can use a class that inherits from the
\inline{InputStream} or \inline{OutputStream} classes, depending on whether
data is to be read or written. This is different from both the approaches of C,
since in Java there are distinct facilities for reading and writing whereas C
only uses a \inline{FILE} that is opened in a reading or writing mode,
rendering write operations on a read-handle invalid during program execution.
Python's file-like objects have adopted similar semantics. In Java, these types
of handles are distinguished at compile-time.

The Java standard library supplies a number of different types of these
streams, most notably the \inline{FileInputStream}/\inline{FileOutputStream}
classes, which allow reading from files in the file system.

To read a file, either the name of the file can be supplied to a
\inline{FileInputStream} as well as a Java \inline{File} instance. The latter
represents a file itself and not a handle to an opened file like \inline{FILE}
in C. After creating an instance of the \inline{FileInputStream}, data can be
read via its \inline{read} method which is very similar to the familiar
\inline{fread} function from C: it reads a number of bytes into an array of
byte-type at an optional offset and returns the number of bytes that were read.

Handling text data is slightly more involved, since usually when dealing with
character data it is useful to use \emph{buffered I/O} to be able to read and
write whole lines, instead of reading single bytes and assembling them into
lines manually. To read a text-file line-wise, one needs to create an instance
of the \inline{FileReader} class and then wrap this instance in an
\inline{BufferedStreamReader}, which supplies an additional \inline{readLine}
method to read the next line of a file.

As for this rather huge taxonomy of classes to deal with I/O, Java has earned a
reputation of being overly complex although the framework itself is quite
flexible.

\section{Python}
\label{sec:python}

Python is a dynamically-typed high level language designed in the the Nineties
and enjoying constant improvement. It has seen rising adoption in the last few
years in scientific communities as well as for web development. Much of this
apotion can be attributed to the simplicity of the language and the thriving
ecosystem.

One important concept in Python is the so called \emph{duck-typing} in which
there is no formal interface like in Java but rather objects that provide
specific behaviors: \emph{If it walks like a duck, it if quacks like a duck,
then it is a duck}

This means that every object can support any interface, as long as it provides
the proper methods and returns the proper values. No special definitions are
required and there is no required class hierarchy.

\subsection{Iterables}
\label{sec:pyiterable}

One important interface in Python is the \emph{Iterable}, that is an object
over which it is possible to iterate. Iterables are only required to support
very limited operations:

\begin{itemize}

  \item Provide a \inline{\_\_next\_\_} method which returns the next value of
	  the iterable.

  \item Throw a \inline{StopIteration} exception after the last element was
	  returned.  This is used to denote that the iterable was consumed and
	  will not provide any more values.

\end{itemize}

Python's built-in datatypes support this interface, therefore implementing
these interfaces in custom types enables the standard Python syntax to use them
just like every other type. In particular, lists support this interface but
also strings and files as well. Thus implementing own custom streaming types is
easy and convenient.

\begin{listing}[H]
  \inputminted[linenos]{python}{iterable.py}
  \caption{An iterable in Python}
  \label{lst:pyiterable}
\end{listing}

\autoref{lst:pyiterable} shows a very simple implementation of an iterable
object. The object returns values indefinitely, so just the first five are
retrieved.

Python also has additional syntactic support for so called \emph{generators}
which are ordinary functions that use the \inline{yield} keyword instead of the
\inline{return} keyword. This causes the functions return value to turn into an
iterable, return the value and suspend. Each element of the iterable causes the
function to resume and run until the next \inline{yield} is reached.  Reaching
the end of the function or a \inline{return} statement causes a
\inline{StopIteration} exception being thrown. This exception is interpreted by
the \inline{for} loop as end-marker, thus stopping to iterate over the
generator. \autoref{lst:pygenerator} demonstrates a simple generator in action.

\begin{listing}[H]
  \inputminted[linenos]{python}{generator.py}
  \caption{A simple generator}
  \label{lst:pygenerator}
\end{listing}

Python's support for generators goes even further by making it possible to pass
values into a function that was suspended when it reached a \inline{yield}
keyword, although the details and syntactic extensions of Python generators are
outside of the scope of discussion.

\subsection{File-like objects}
\label{sec:pyfile}

A very useful concept in Python is the so-called \enquote{file-like object}.
These objects are a simple abstraction of a file in the
filesystem, similar to C's \inline{FILE} data type. Unlike C,
\enquote{file-like} objects don't need to be of any specific type but are
required to provide a specific interface in a duck-typing manner.

The first \enquote{file-like object} in Python was the object returned by the
function \inline{open} which returns a reference to an open file, similar to
\inline{fopen} in C. The type of this object is \inline{file} which explains
the naming of \enquote{file-like} objects.

A \enquote{file-like} object usually provides a minimal interface of a
\inline{read} method for files that are meant for reading and \inline{write}
for files that are meant for writing. \inline{read} takes an optional integer
parameter which specifies how many bytes to read at maximum, whereas the
default is to read the data until the end. The write method takes a
string\footnote{Python 2.x uses the \inline{str}-bytestring type, Python 3.x
uses either the \inline{str} Unicode string type or \inline{bytes} type} and
writes it to the file. The interface is very simple but for real files it can
also be extended by adding methods to seek inside of a file, getting the inode
number of the file etc.

\enquote{File-like} objects are very useful to deal with code that requires a
reference to a file but the file to be used is not on a local file system and
cannot be opened using \inline{open}. Examples of such files include files in
archives like a text-file inside a ZIP archive or remote files like a file on a
HTTP server. \autoref{lst:pyremote} creates such a \enquote{file-like} object
and prints its contents. This object could also be passed to most functions by
most functions that expect to work with files and work just as well.

\begin{listing}[H]
  \inputminted[linenos]{python}{remote.py}
  \caption{A \enquote{file-like object} from a URL}
  \label{lst:pyremote}
\end{listing}

Iteration semantics over a \enquote{file-like} object are not defined by the
interface, but iteration over proper \enquote{file} objects causes Python to
iterate over the lines in a lazy fashion: each line is only read on demand and
discarded afterwards. This enables Python to read files of arbitrary size using
this interface.

\chapter{Implementation}
\label{sec:implementation}

Implementing a functional streaming API in specifically in OCaml has a couple
of advantages. OCaml enables type-safe development which is useful for
environments where the reliability of software is crucial and having code that
can be proven correct by the type inference is a big advantage. Although it
does not obsolete thorough unit testing, a type-safe language can provide some
amount of extra safety.

The OCaml compiler can generate byte-code for a wide range of
platforms\footnote{The Debian project listsAMD64, ARM, x86, Itanium, MIPS, S390
and SPARC as supported systems on
\url{http://packages.debian.org/wheezy/ocaml-nox}} well as native code for some
of these\footnote{Debian lists AMD64, ARM, x86, PowerPC, and SPARC as supported
platforms, see
\url{http://packages.debian.org/wheezy/ocaml-native-compilers}} and is well
known for well-performing code. Thus the choice of OCaml as an implementation
language is obvious.

A recent advance in the OCaml community has been the introduction of
OPAM~\cite{gazagnaire2013opam}, a package manager along with a catalogue of
packages available for programmers.  OPAM fills the same role for OCaml that
systems like CPAN for Perl, the Python Package Index (PyPI) as well as the CTAN
for \LaTeX fulfill. This development was made possible by the convergence to a
common package description tool, OASIS~\cite{legall2012oasis}. OASIS defines a
format to describe package metainformation like name, version number, short
description as well as instruction on how to build it.  Apart from this format,
OASIS can generate files to build the project similar to GNU autotools or CMake
and also Cabal for Haskell, but with a focus on building OCaml
projects~\cite{legall2011quickstart}.

As such, while implementing this software, great care has been exercised to
adhere to current OCaml community practices, so potential users and
contributors will not be put off by idiosyncracies of software developed in
isolation. This means, among others, that the software will use OASIS and the
finished package will be available in the OPAM package directory under a Free
Software license. It also means, that the software was written with an accepted
style guide~\cite{ocamlstyle} in mind so any proficient OCaml programmer
looking at the software is not distracted by unusual coding practices but can
concentrate fully on the functionality.

\section{Architecture}
\label{sec:architecture}

As outlined before, implementing everything from scratch would take long time
and be quite useless, therefore OStreamer uses existing code, extending it
where possible. An overview of the system architecture is provided by
\autoref{fig:architecture}. The lowest level are usually C~libraries that
provide functionality, the middle-tier are wrapper libraries. OStreamer is on
the highest level, providing a universal interface to these libraries. The
highlighted part is implemented, the rest are possible extensions.

\begin{figure}[h]
  \centering
  \input{architecture}
  \caption{High-level view of system architecture.}
  \label{fig:architecture}
\end{figure}

\section{Compression}
\label{sec:compression}

There are many possibilities to demonstrate the use of a streaming library so
to find an application which is interesting enough for the thesis while not too
complex to exceed the scope, compression is a good fit.

From the viewpoint of the OCaml software ecosystem, this pick makes sense, as
there is no widely adopted software library to deal with compression in a
universal way. There is a number of solutions an OCaml programmer can choose
from, but each suffers from some problems.

\subsection{Possible alternatives}
\label{sec:alternatives}

There is some selection in solutions that cover only some of the functionality
that is usually expected from a compression library.

\begin{itemize}
  \item camlzip\footnote{\url{https://forge.ocamlcore.org/projects/camlzip/}}:
    Mature library, but supports only ZIP archives and GZip files. One specific
    limitation is
    the lack of support for in-memory data which requires to read and write
    temporary files causing bad performance. Also, appears to be in maintenance
    mode with hardly any changes in the last years.
  \item OCamlBZ2\footnote{\url{https://forge.ocamlcore.org/projects/camlbz2/}}:
    This library is limited to handle only bz2 compression and is a direct
    binding to libbz2. Maintenance of the library seems to have stopped many
    years ago after only two releases. One disadvantage is that raw bz2
    streams are rare — usually multiple files are wrapped in tar archives,
    for which this library has no support.
  \item ocaml-tar\footnote{\url{https://github.com/samoht/ocaml-tar}}:
    implements tar format archives in pure OCaml code. This implements
    \emph{one} type of tar, whereas libarchive supports multiple variants.
  \item ocaml-archive\footnote{\url{https://forge.ocamlcore.org/projects/ocaml-archive/}}:
    The most comparable library to this effort, unfortunately not a complete
    binding and only one single version ever released that binds an old version
    of libarchive that is considered \enquote{legacy} by the libarchive
    developers. In addition, this binding is incomplete and does not feature
    compression support. Yet useful for transfering some ideas on how to
    implement the C binding.
\end{itemize}

\subsection{libarchive}
\label{sec:libarchive}

As an alternative, there exists a library named
libarchive\footnote{\url{http://www.libarchive.org/}} is a library designed to
handle all compression needs for low-level programming. This is very useful for
us, as it provides us with many features that we will need in implementing this
thesis.

Libarchive originated in the FreeBSD project but is also used by many other
systems. One of the problems before libarchive was that different libraries
like zlib (gzip) and libbz2 (bz2) have different interfaces, so to add support
for a particular format, the developer needed to do a tedious effort to add
support manually. Also, some compression formats require container formats,
e.g. the popular ZIP format consists of a format to bundle files which are in
turn separately compressed using \enquote{deflate} and \enquote{store}
algorithms. A similar case is the TAR (\enquote{Tape ARchive}) format popular
on Unix which bundles files in one single file and usually gets compressed
using a regular compressor. The TAR format does not have a canonical
implementation -- there are separate implementations by the GNU project, the
BSD project, in the Python Standard Library etc. Usually programmers have
reimplement the format and its variants.

Libarchive solves this by providing a common interface to two mechanisms:
container formats, called \enquote{formats} in libarchive as well as
compression formats, called \enquote{filters}. Not all formats that can be read
can also be written, but the variety of options that libarchive supports is
quite huge.

Formats supported be libarchive include:

\begin{itemize}
  \item \emph{7z}, the compression format of 7-Zip
  \item \emph{AR}, used for static libraries in Unix
  \item \emph{CAB}, Microsoft cabinet files for installers, read-only support
  \item \emph{CPIO}, initial ramdisk for booting a GNU/Linux system
  \item \emph{ISO 9660}, CD-ROM image files
  \item \emph{LHA}, popular compression format in Japan, read-only support
  \item \emph{RAR}, compression format of WinRAR, read-only support
  \item \emph{TAR}, typical file exchange format in Unix systems, with
    \emph{ustar}, \emph{GNU} and \emph{PAX} variants supported.
  \item \emph{XAR}, format used by the RPM5 package manager
  \item \emph{ZIP}, very popular archive format
\end{itemize}

Apart from these formats libarchive also supports various compression filters:

\begin{itemize}
  \item \emph{bzip2}, popular alternative to \emph{gzip} with better
    compression results~\cite{kivijarvi1998comparison}
  \item \emph{compress}, a mostly obsolete compression format (\inline{.Z})
    used on Unix
  \item \emph{grzip}, a compressor that applies special preprocessing
  \item \emph{gzip}, a popular format with decent compression and decent speed
  \item \emph{lrzip}, compressor with multiple compression backends (LZMA, ZPAQ,
    LZO, gzip, bzip2)
  \item \emph{LZO}, an algorithm designed with very fast decompression in mind
  \item \emph{RPM}, packages for the RPM package manager used in Fedora Linux,
    openSUSE and a variety of other distributions\footnote{While RPM is used to
    store multiple files, it is essentially an CPIO archive compressed with
    GZip wrapped with some meta data as described in
    \url{http://www.rpm.org/max-rpm/s1-rpm-file-format-rpm-file-format.html}}
  \item \emph{UU}, UUencode, a way to encode 8 bit data into printable ASCII
    characters
  \item \emph{XZ}, a compressor with high compression using the LZMA2 algorithm
    from 7-Zip, with usually higher compression rates than
    BZip2~\cite{ijrcct96}
\end{itemize}

In addition to the provided support, it is also possible to create own filters
by registering external programs that libarchive will call and interface
automatically, so creating new filters is very simple.

libarchive also provides \inline{bsdtar}, a program with a command line
interface similar to \inline{tar} but with support for all formats that
libarchive supports, providing a consistent interface for handling all kinds of
archive files from the command line.

When trying to read files that are not in a specific container format,
libarchive uses the so-called \enquote{raw} format, which just runs a filter.
This is useful to decompress files that are just processed with e.g. gzip but
not in a tar file. During implementation it turned out that there was only a
format for \emph{reading} raw files, but \emph{writing} these was not possible.

I wrote a patch for libarchive to add such a filter and submitted it to the
upstream author. After a number of revisions on functionality and code style \&
conventions, the patch was added to the upstream version of libarchive,
together with unit tests. In the process of writing this patch, I found that
setting some fields of a compression format to \inline{NULL} caused libarchive
to crash. Consultation with the libarchive author confirmed this as a bug, so I
also wrote and submitted a patch for this issue which has also been included in
the upstream version.

Adding new formats to libarchive is essentially simple, since it provides hooks
for implementing own formats. \autoref{lst:archiveformat} sets these hooks in
the lines 14 to 23.

\begin{listing}[h]
  \inputminted[linenos,fontsize=\small]{c}{archive-set-format.c}
  \caption{Initializing a format}
  \label{lst:archiveformat}
\end{listing}

Special care was taken in the raw format to only allow one file entry to be
written to the archive, as \autoref{lst:archiveheader} demonstrates. This entry
also gets limited to be a regular file, since other file types do not make
sense.

\begin{listing}[h]
  \inputminted[linenos,fontsize=\small]{c}{archive-write-header.c}
  \caption{Checks for file type and number of files attempted to write}
  \label{lst:archiveheader}
\end{listing}

Writing the raw data is the simplest part, evidenced by
\autoref{lst:archivedata}.

\begin{listing}[h]
  \inputminted[linenos,fontsize=\small]{c}{archive-write-data.c}
  \caption{Writing data into a \enquote{raw} format file}
  \label{lst:archivedata}
\end{listing}

With this functionality available, an OCaml wrapper on top of libarchive can be
constructed.

\subsection{Foreign function interface}
\label{sec:ffi}

Now that we have chosen libarchive as base for the implementation of
compression, we need a way to bring the functionality of libarchive to OCaml.
The OCaml compiler supports extending the functionality of the language not
only by writing OCaml code but it also allows to interoperate with C code. This
functionality is crucial to integrate with external systems which often export
their functionality in the form of C libraries. In the case of this thesis, we
can thus leverage the functionality of libarchive to demonstrate the streaming
interface as well as provide a first useful application of the streaming
interface.

This functionality to interface with \enquote{foreign} code is called a
\enquote{foreign function interface} (FFI). In the case of OCaml, the language
has a special construct to declare \enquote{external} functions by giving them
an OCaml name, an OCaml type signature and a C name as string. The function
name has to be equal to a function in C that gets linked together with the
OCaml code.

From the C perspecitve, OCaml values have the type \inline{value} (defined in
the OCaml header files) and can be converted to C values using a set of C
macros as well as constructed from C values with another set of macros. This
allows to create wrapper functions that extract the C values from the OCaml
values, call the C functions, pack their results into OCaml values and return
to the OCaml code.

\section{Low-level binding}
\label{sec:lowlevel}

To create a sensible binding to libarchive we will start creating a layer of
abstractions, to ease the usage of the binding. Abstractions like this are
useful, because they ease the understanding of code, by hiding the irrelevant
parts~\cite{liskov1986abstraction}. In our case, all management of memory is
irrelevant since in OCaml we can let the runtime deal with memory management.
Therefore, we construct a binding which hides this all and provides a somewhat
more natural view of the libarchive API for high-level programmers.

We will start with a low-level abstraction which represents the C API of
libarchive in OCaml, meaning that many functions will have similar names and do
very similar things, except for memory management. From that, we are going to
use what Barbara Liskov calls procedural abstractions to create a more
convenient way to use the functionality that is not limited by what the C
programming language supports, we are free to constuct any kind of API that can
be expressed in OCaml.

In \autoref{sec:functional} we are going to go beyond an simple interface. We
will leverage some advanced features of OCaml to deal with errors that happen
on run time as well as provide a vastly easier interface so people wanting to
use it do not need to understand the functionality of the unterlying libarchive
library.

The lowest-level binding code for this thesis creates an OCaml wrapper for
libarchive which is very similar to the C API of libarchive. This means the
wrapper code in C only does conversion between OCaml and C values as shown in
\autoref{lst:simplewrap} and provides a very un-functional interface to OCaml,
like in \autoref{lst:simpletype} which mimics the C API.

This approach was chosen to keep as much as possible of the binding in OCaml
code and allow the creation of a higher level binding. The higher level binding
can be written in imperative-style OCaml code but will expose a functional
interface.

\begin{listing}[h]
  \inputminted[linenos]{c}{simple-wrap.c}
  \caption{A very simple function from libarchive, wrapped using the OCaml FFI}
  \label{lst:simplewrap}
\end{listing}

\begin{listing}[h]
  \inputminted[linenos]{ocaml}{simple-wrap.ml}
  \caption{OCaml type definition for \autoref{lst:simplewrap}}
  \label{lst:simpletype}
\end{listing}

One advantage of the low level binding is that despite being low-level, it
introduces some additional type safety. In C and libarchive it is usual for a
function to return an exit code from a function to determine whether execution
was successful or not. libarchive usually returns an integer value whereas the
low-level binding maps the resulting value into a union type, so errors from
libarchive do not go undetected.

\subsection{Garbage collection}
\label{sec:gc}

To free the low level interface from manual memory management, we leverage the
OCaml runtime to do this for us. Essentially, we only want to create values. In
an ideal world that would be enough since we'd have infinite memory.
Unfortunately the amount of memory we have is limited, so the values which we
have used and won't need any more have to be cleaned up. Fortunately, for this
exact purpose we can employ garbage collection.

Garbage collection is the process of reclaiming main memory from data that is
not used anymore by the program. Manual memory management is a complicated
process so many languages like OCaml, Java or Python include an automatic
garbage collector which frees the memory on the heap when some data (a value or
object) is not referenced from a program, usually due to a variable moving out
of a function scope. In this case, the garbage collector runs and deletes the
object so the memory can either be reused by the program or returned to the
operating system. The concept of garbage collection is not new, it was invented
in 1960~\cite{mccarthy1960recursive} and perfected since.

Yet many other languages, among them C, only reclaim memory from variables that
are stored on the stack. If a dynamic data structure is necessary, the
programmer needs to manually \enquote{allocate} (reserve) memory on the heap
using functions like \inline{malloc(3)}. This memory is reserved for the whole
runtime of the program unless the memory is freed using the \inline{free(3)}
function.

The binding in this bachelor thesis is written in both C and OCaml, so one has
to provide hints to the garbage collector of the OCaml runtime on how to treat
the OCaml values that are exposed to C as well as how to treat the C values
that are exposed to OCaml.

\subsubsection{Handling OCaml values in C}
\label{sec:gcvalue}

For communicating with the C library, we need a way to make the OCaml values
accessible to the C code, so it might work with the information contained in
the OCaml values.

As shown in \autoref{lst:simplewrap}, the values from OCaml are passed to be of
the \inline{value} type in C. This type is opaque, so the actual implementation
is not of particular interest.

The first action of a C wrapper function is to use the \inline{CAMLparam}
macro\footnote{In particular \inline{CAMLparam1} which means that it takes only
one argument} to register the parameter of the function, in case of
\autoref{lst:simplewrap}, \inline{unit}, to the garbage collector as being in
use, so it is not allowed to collect it just yet.  In addition, if the garbage
collector decides to move the memory block\footnote{the OCaml garbage collector
not only frees memory but also reorders the memory to minimize
fragmentation in a process called \enquote{compaction}} that holds the value,
it needs to update the pointer that \inline{unit} points to, therefore such a
variable needs to be registered to the GC first. In this example, the value
passed is an instance of the OCaml unit type, which does not hold information
that would require being extracted. Yet it is required, since OCaml functions
are required to have one argument, so it is customary to pass an argument of
unit type.

Second, a new local variable is created, \inline{r}, which will hold an OCaml
value. It also notifies the GC of the presence of this variable to prevent its
collection.

Then the computation is done and the result of the computation, in this case an
integer value representing a version number, is converted from a C \inline{int}
type into an OCaml \inline{value} type.

At the end, instead of a \inline{return} statement, a special
\inline{CAMLreturn} macro is called which returns the local variable \inline{r}
and tells the garbage collector that all other previously declared values — in
this case only \inline{unit} — can be discarded.

As an optimization, the fact that the memory \emph{can} be discarded does not
mean that it \emph{is} immediately discarded. As a run of the garbage collector
takes time, the collection is usually delayed until enough \enquote{garbage}
has piled up. Very short programs may not ever see a run of the garbage
collectior since when the program terminates all memory is freed automatically,
so collection of garbage immediately before exiting would only cause slowdown.

This optimization also has the downside that failures in memory handling are
not detected, unless the garbage collector is activated which might not always
happen in short programs like unit tests. In fact, a previous version of this
binding never used \inline{CAMLparam}/\inline{CAMLlocal}/\inline{CAMLreturn}
and ran without problems — until garbage collection was forced, in which case
it crashed during garbage collection. Thus, as a recommendation for unit tests
which test C code bindings it is a good practice to call the garbage collector
manually at the end to make sure that the C binding has not created problems
with garbage collection.

% https://sympa.inria.fr/sympa/arc/caml-list/2013-04/msg00082.html

\subsubsection{Handling C values in OCaml}
\label{sec:gcblock}

As we have seen how to pass information from OCaml to C and get information
back, we still have another issue open: how to deal with data that was returned
from the C code. In most cases, it can be converted to OCaml values. Not all
values \emph{can} be converted though, especially when the C code returns
pointers to opaque structures. These don't have an useful OCaml representation,
so it is best to just pass them as opaque values which will only be used as
arguments to C functions that expect these kind of pointers.

When getting a pointer from the C code, another problem arises: the user has to
take case of freeing the objects. For this problem, there are two possible
solutions: either expose C functions to OCaml that handle freeing the allocated
resources when the OCaml programmer knows he won't be using them furthermore or
putting these objects under the control of the garbage collector of OCaml.

Both approaches have both advantages as well as disadvantages:

\begin{itemize}
  \item Explicit freeing has the advantage of requiring the least memory, if
    used properly. The programmer can free objects immediately after he is done
    with them and does not have to wait for the references to the objects to
    exit the scope and the garbage collector starting up. Forgetting to free
    unneeded references will lead to memory leaks. Also, using references after
    they have already been freed by mistake might lead to crashes.
  \item Implicit garbage collection has the advantage of never forgetting to
    free memory blocks, although it might take some time until the garbage
    collector decides to free the memory. This is a common behaviour for
    values returned from ordinary functions implemented in OCaml code.
\end{itemize}

For the binding, it was decided to be consistent with the OCaml language and
choose the safer route, that is to manage the objects with the garbage
collector to rule out crashes due to incorrect memory management.

To use the OCaml garbage collector one needs to define a so-called custom
block. OCaml manages its values in \enquote{blocks} and has a number of
predefined blocks like integers and floating point numbers. To manage C
objects, one needs to create a new block. Such a block is allocated by
\inline{caml\_custom\_alloc} which takes a pointer to a struct as first
argument. This struct includes pointers to callback functions as seen in
\autoref{lst:customblock}. All callbacks except for the finalization callback
are set to default implementations provided by OCaml, the finalization callback
is a custom C function to handle the de-allocation of the \emph{contents} of
the block. Whereas the deallocation of the block itself is handled by the
garbage collector.

\begin{listing}[h]
  \inputminted[linenos]{c}{custom-block.c}
  \caption{The definition of a custom block struct}
  \label{lst:customblock}
\end{listing}

The binding to libarchive features a number of objects that are created as
custom blocks and feature their own specific finalization functions:

\begin{itemize}
  \item \inline{archive}, representing an archive opened for reading or
    writing.
  \item \inline{write\_buffer}, a dynamically growing buffer to which data can
    be written.
  \item \inline{written\_ptr}, a pointer to a value that holds the number of
    bytes that were written to the \inline{write\_buffer}, used for reading
    the contens of said buffer.
  \item \inline{entry}, representing an entry in the archive.
\end{itemize}

Usually, read and write archive handles have to be treated in distinct ways,
namely \inline{archive\_read\_free} and \inline{archive\_write\_free}. As these
both have the exact same signature, do the exact same thing and libarchive
knows internally whether a handle is of reading or writing type\footnote{An
information that is not available to code that uses libarchive}, libarchive was
extended with a generic finalization function, \inline{archive\_free}, which
can be called on both types of handles. Thus, both read and write handles are
represented by the same custom block because they share the implementation of
the finalization function.

The opposite is true for entry objects: libarchive frees the entry objects by
itself if they were created by libarchive. If they were created by the user of
the code, they need to be freed manually. An example of this is when reading an
archive, libarchive returns entry objects which it created by itself and will
free them by itself. On the other hand when creating an archive, each entry
object has to be created by the user and manually freed. Here we will call
entries created by libarchive \enquote{shared entries} and those created by the
library user \enquote{own entries}.

The C code wrapper therefore uses two different structs to deal with these:
\enquote{shared} entries get the default OCaml finalizer implementation which
does nothing, because the entry \emph{will} be freed by libarchive. Freeing it
would be an error, because then libarchive would later free the entry object
\emph{again}, thus causing a double-free and crash. The implementation of
custom blocks for \emph{own} entries defines a custom finalization function
which calls \inline{archive\_entry\_free}. Not calling it would be an error and
leak entry objects. Yet this distinction is only in the C code — both custom
blocks are exported to the OCaml code as one single type. This seems odd, but
it is correct as the only difference between these two entry types is that they
have different finalization functions but the \emph{content} of the block is
the same — a pointer to an entry object.

\subsection{Memory allocator}
\label{sec:allocator}

For writing out compressed data, libarchive supports a number of modes:

\begin{itemize}
  \item Writing to a file
  \item Writing to a file descriptor
  \item Writing to a memory buffer
  \item A custom function
\end{itemize}

These functions are very useful when writing code directly using the C API,
since writing to file and to file descriptors saves the programmer from having
to do anything besides opening a file or file descriptor and libarchive handles
writing out the data itself. Unfortunately, these modes cannot be used for a
stream interface, since at the point of writing the compressed data, it is not
yet known what to do with the data: save it to a file or maybe stream it
through a socket to some remote computer. In the latter case, saving the data
to disk would serve no point.

Therefore, the stream interface in this library needs libarchive to write the
compressed data into memory as this is the most flexible alternative from which
saving to a file or streaming to a remote computer can still be done.
libarchive provides such a function, unfortunately this function saves into a
\emph{fixed} memory buffer. This creates a number of problems since it is not
known how big an archive that is produced by libarchive will be. It might turn
out very small on efficient compression, e.g. text, in which case a fixed
buffer is not used and lot of memory is wasted. On the other hand, when
compressing already compressed data like compressed music or movies, it might
turn out even larger than before, thus overflowing a buffer.

To prevent overflows yet using the memory efficiently, the wrapper code in this
thesis uses a smarter approach: the buffer is resized while writing the
archive. There are distinct goals that are to be optimized:

\begin{enumerate}
  \item Safety: The buffer should never overflow as this causes memory
    corruption which leads to incorrect behaviour and security problems
  \item Resource-saving: The buffer should not waste unnecessary memory
  \item Efficiency: Due to how memory allocation works, a minimal number
    of resize operations are desirable, since each resize might require
    to copy previous contents of the buffer
\end{enumerate}

Before each write, the buffer is checked to make sure there is enough space
left in the buffer to save the data. The goal of being resource friendly would
be fulfilled by resizing the buffer to the desired size to fit the data, but
this will cause many resize operations. As a measure against this, the buffer
gets resized using an empiric formula:

\begin{displaymath}
\text{new\_length} = \lfloor 1.5 \times \text{current\_length} \rfloor
\end{displaymath}

This factor is a compromise between memory-usage and number of allocations. If
the buffer required is small, it will not waste much memory, if the buffer
required is huge, there will be less resize operations required. In addition,
the initial buffer size is $4096$~byte, to prevent lots of small resize
operations at the beginning. After each new size calculation, the new buffer
size is sanity-checked whether it really fits the new data.

The simple algorithm used prevents excessive resizes while minimizing memory
usage.

\section{Functional streaming interface}
\label{sec:functional}

As the low level interface was implemented we had a way to do compression and
decompression in OCaml via libarchive, but in a very inconvenient matter which
has to do with the fact that the low level interface reflects the C interface
from libarchive: each operation require quite a lot of set up to do a simple
thing like extracting. If the functions required for set up would be called in
an incorrect order, the system would just crash. Therefore, some higher level
abstractions will be introduced to make the interface easier to use and the
usage less error prone.

We will make the interface less error prone by adding more information to the
types by using phantom types, described in \autoref{sec:phantom}. Also, apart
from programmer errors during programming, there might be errors happening on
run time: the archive that is supposed to be read does not exist, the archive
file is corrupt or maybe the data can't be written because the disk is full.
For this, C code commonly uses special return values. The downside of this
approach is that the programmer might forget to check the return value, so the
program continues to run despite the error causing even more problems and
\enquote{weird} behaviour.

Some programming languages use \enquote{exceptions} instead — special error
states that halt the normal execution so the programmer will have to deal with
this exception. OCaml does support exceptions, yet working with exceptions in a
functional style is inconvenient, as error handling and the function
composition that is popular in functional code mixes poorly. To avoid these
problems, the implementation of this thesis does not use exceptions but a
different way to signal errors — the error monad which will be analyzed in
depth in \autoref{sec:errormonad}.

\subsection{Phantom types}
\label{sec:phantom}

The low-level binding wraps a number of types from libarchive in an
\emph{opaque} way: they are generated by the C API and used by the C API. In
the OCaml code they are treated as a black box. This approach has the advantage
that changes of the type in the C API do not affect the OCaml binding at all.
The two most important types are \inline{archive} and \inline{entry}. The
\inline{archive} type represents an archive file handle. It is a long-lived
object, it has to exist the whole time an archive is opened and it is passed to
all functions in libarchive that handle archives. The \inline{entry} object
represents an entry in an archive, be it file or folder and is only valid for
one single entry.

The \inline{archive} type can be thought of a file handle, similar to
\inline{FILE} from C. Similar to the C type, it can be both open and closed. In
addition, libarchive differentiates between \enquote{read} and \enquote{write}
\inline{archive} handles: \enquote{read} handles are used for opening and
extracting files from an archive and are created with a specific API call,
\enquote{write} handles are used to create archives and have their own specific
creation function. For simplicity, libarchive does not differentiate between
these types of handle in the type signature as both handle types are of type
\inline{struct archive}, yet writing to a \enquote{read}-handle is not a valid
operation.

Apart from the \enquote{open} and \enquote{closed} states more possible states
exist: after creating a \enquote{read}-handle, the compressed data has yet to
be passed to libarchive, as such the handle can be considered \enquote{empty}
on creatin and \enquote{populated} after feeding in the compressed data.
Decompressing entries from \enquote{read} handles of course only makes sense if
they are \enquote{populated}.

With ordinary OCaml types, an \inline{archive} handle would be represented by
an \inline{archive} type. This approach works very well but it doesn't
differentiate between \enquote{read}/\enquote{write} handles nor their state,
whether they are opened or closed.

This thesis improves this by splitting the handle in two distinct types, so
passing a \inline{readhandle} into a function that expects a
\inline{writehandle} is directly disallowed by the type system and such a
program does not compile. This can already eliminate a lot of possible bugs
that were possible with the C API. The implementation is trivial, since
libarchive is always strict on requiring either \enquote{read} handles or
\enquote{write} handles but never both. So the OCaml binding can just state in
the \inline{external} definition that the return value of the \enquote{read}
handle creation function is \inline{readhandle} and not \inline{archive}. All
functions that would take C \inline{archive} \enquote{read} handles can be
declared to take OCaml \inline{readhandles} instead. \enquote{write} handles
and their functions are treated in an analogous way.

This solves accidental mixing up of \enquote{read} and \enquote{write} handles,
but it does not prevent extracting archives that weren't yet
populated\footnote{During development, exactly this happened — the author tried
reading from an archive without feeding the compressed archive to the handle
and wondered why nothing was happening}. This is where OCaml phantom types are
useful.

Phantom types are called \enquote{phantom} because the actual types are not
exposed in the signature but rather hidden in the implementation, as
\autoref{lst:phantom} shows. This causes the OCaml compiler to prohibit calling
a function with an incorrect phantom type~\cite{rwmj2008}. The code sample
introduces new polymorphic variant types~\cite{ocamlmanual} to implement
additional annotations.  The code in \autoref{lst:phantom} adds an annotation
in float types on which unit the float value represents and prevents
programmers from mixing meters with feet, an error that can be easily done and
is hard to detect. The advantage is gained while still using the efficient,
untagged \inline{float} representation at run time~\cite{hinze2003fun},
\cite{gibbons2003fun}.

In the same fashion, the OCaml libarchive binding uses polymorphic variants
types to annotate the signatures with the state of the handle (\inline{Open},
\inline{Empty}, \inline{Populated}, \inline{Closed}) as shown in
\autoref{lst:phantomsigs} so using the handles in an invalid way is already
caught by the compiler.

\begin{listing}[H]
  \inputminted[linenos]{ocaml}{phantom.ml}
  \caption{A simple example of phantom types~\cite{rwmj2008}}
  \label{lst:phantom}
\end{listing}

\begin{listing}[H]
  \inputminted[linenos]{ocaml}{signatures.ml}
  \caption{OCaml signatures of the libarchive binding}
  \label{lst:phantomsigs}
\end{listing}

\subsection{Error monad}
\label{sec:errormonad}

\autoref{lst:phantomsigs} shows another feature of the functional OCaml
interface: the error reporting. OCaml supports a number of ways to deal with
failed execution. One of these mechanisms is exceptions, unfortunately
exceptions don't mix too well with functional code. OCaml also comes with an
\inline{Option} type, which can represent a success with \inline{Some} and a
value as well as failure with \inline{None}. This mechanism mirrors the
\inline{Maybe} monad in Haskell. As far as the success case is concerned, the
\inline{Option} type is fine, but when an error occurs, it would be good if the
failure state were able to pass some information to the programmer what the
actual error was instead of just swallowing it.

In Haskell the logical extension of the \inline{Maybe} monad is the
\inline{Error} monad and creating such a data type in OCaml is very
simple~\cite{bh2007}. Using the \inline{Error} monad in OCaml it is very easy
to write code in a sequential way and match the result with pattern matching to
either get the desired data or retrieve the error message.

The way it is used, the programmer just chains calls to the binding. If
everything worked correctly, the result is \inline{Success} with the correct
data, or \inline{Failure} otherwise. In case some immediate computation failed,
the \inline{Failure} state just propagates through the chain and can be matched
at the end. \autoref{lst:error} shows the complete implementation of the data
type. The failure case returns both the error code from libarchive as well as
the error string that libarchive emits.

\begin{listing}[H]
  \inputminted[linenos]{ocaml}{error.ml}
  \caption{Implementation of the \inline{Error} monad}
  \label{lst:error}
\end{listing}

\subsection{Usage of monadic data}
\label{sec:monadicusage}

Due to the monadic return value of the functions, it is possible to chain
execution using the \inline{bind} operator. The \inline{bind} operator is
usually spelled \inline{>>=}\footnote{The current logo of Haskell,
\haskelllogo[unit=0.2mm], is in fact a stylized \inline{>>=}
operator} but as OCaml does not have monads in the standard library, it doesn't
define a \inline{bind} operator, so this has to be implemented.

In the case of the error monad (\autoref{sec:errormonad}) the implementation of
the functionality of the \inline{bind} operator is trivial, as shown in
\autoref{lst:error}. But unlike Haskell, which allows every function to be used
in an infix operator context, in OCaml a function needs to be named in a
specific fashion to be able to be used as an infix operator.

% TODO: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html

Therefore, a different name has to be chosen. One possibility is \inline{|>},
to invoke familiarity with the \inline{|} (pipe) operator from shell programs.
In OCaml, \inline{|} cannot be redefined because it is a keyword, but
\inline{|>} can be defined and shares the precedence rules with the familiar
\inline{or} operator. Another alternative is direct usage of the \inline{>>=}
operator, which can also be defined in OCaml and invokes familiarity from other
languages.

The actual implementation on the other hand is trivial, since operators in
OCaml are defined like regular functions, both alternatives are shown in
\autoref{lst:operators}. This is not a \emph{general} \inline{bind} operator as
it only works on one type of monad, therefore it makes sense to define it in a
separate module that can be included using \inline{open} when needed to prevent
cluttering up the namespace with operators. An alternative is to use a local
\inline{let} definition to create a local binding for the operator. This works
exactly like any other \inline{let} binding for other values, there are no
special rules involved.

\begin{listing}[H]
  \begin{minted}[linenos]{ocaml}
let (|>) = ErrorMonad.bind
let (>>=) = ErrorMonad.bind
  \end{minted}
  \caption{Possible and sensible operator choices for \inline{bind} the bind
    operators together with the \emph{complete} implementation}
  \label{lst:operators}
\end{listing}

The way \inline{bind} works for the error monad described in
\autoref{sec:errormonad} is to pattern-match the value and if it is not the
\inline{Failure} state, run a function with the unwrapped value might result in
either a \inline{Success} or \inline{Failure} return value. This procedure
might be chained multiple times, so functions can be arranged in a pipe-like
fashion similar to pipes from shell programming as demonstrated in
\autoref{lst:bindpipe}.

\begin{listing}[H]
  \begin{minted}[linenos]{ocaml}
match Pipe.construct raw_gz_file >>= Pipe.decompress with
| ErrorMonad.Success (value) -> _
| ErrorMonad.Failure (code, message) -> _
  \end{minted}
  \caption{Pipes implemented with the bind operator from \autoref{lst:operators}}
  \label{lst:bindpipe}
\end{listing}

\chapter{Discussion}
\label{sec:discussion}

With the project in a well working state, it is useful to check on how this
thesis has improved the situation in (not only) the OCaml ecosystem, where this
work could lead to in the future and of course, what insights were gained in
the process.

\section{Future improvements}
\label{sec:future}

While the work performed in this thesis presents a complete effort, it does not
mean that there are no possibilities of improvement. The possible improvements
that come to mind divide into two categories:

\begin{enumerate}
  \item \emph{Stream type additions}: currently OStreamer supports working with
    compressed data but is written with extensibility in mind. Support for
    other types of data can be added, e.g. for audio data a binding to the
    audio framework GStreamer\footnote{\url{http://gstreamer.freedesktop.org/}}
    could be added. In fact, there are already OCaml bindings which could be
    integrated easily into OStreamer. Similar with video data or other kinds of
    data that can be conveniently represented as streams
  \item \emph{Optimizations}: currently each operation in the chain runs in an
    \enquote{eager} fashion: it immediately computes its result and provides
    this result to the next link in the chain. This works well but leads to
    unnecessary work in some cases: to decompress a ZIP file and recompress it
    as compressed TAR file the data is currently decompressed in the C layer,
    handed to the OCaml layer and then recompressed in the C layer in the new
    format. Fortunately, libarchive can write directly to a new format, so
    returning the decompressed data to OCaml is useless.  If the chain of
    operations were first preprocessed first one could detect such roundtrips
    and optimize the operations to increase the performance.
\end{enumerate}

\section{Conclusion}
\label{sec:conclusion}

% What we did
% Found a nice API
% Applied advanced functional programming for such
% Extended libarchive
% Created compression library for OCaml

In the beginning we illustrated different approaches on stream processing and
identified a lack of useful compression libraries for OCaml. We created a
binding for libarchive which improves on the type safety of the underlying C
library by using advanced features of the OCaml type system as well as the
garbage collection provided by its runtime. Out of this safe, low level library
we created a higher level API which wraps the imperative-style low level
binding into a functional style API that is simple and natural to use for
programmers. As such, we have created a software that will fill a need for
OCaml programmers and be a joy to use.

In the process of the creation of the binding, we fixed deficiencies in
libarchive as well as extended its functionality, contributing back the changes
to the original project where it may benefit all users of libarchive, which
reaches beyond the OCaml community\footnote{libarchive is packaged in all major
Linux distributions, BSD systems and available for many other operating
systems}.

With this thesis, we also provided useful explanations on the OCaml C API and
the interaction of the garbage collector which weren't yet available in one
place. The previously existing documentation left some questions unanswered,
like the reason many of the macros exist and when they are to be used.

We gained insights on how OCaml and the build tools around it work, how unit
testing in OCaml can be implemented. We saw in \autoref{sec:errormonad} how
seemingly complex topics like monads can be successfully used to create
abstractions that make things \emph{easier} and more convenient. We ventured
into the topic of type safety and used the type system to encode the state of
the system to prevent programmer mistakes in \autoref{sec:phantom}. Over all,
many topics were combined to create a unique and hopefully in the long run
useful software.

\printbibliography
\end{document}
